name: 'Get GitHub App JWT Token'
description: 'Generate a JWT token for GitHub App authentication'
inputs:
  app-id:
    description: 'GitHub App ID'
    required: true
  private-key:
    description: 'GitHub App private key (PEM format)'
    required: true
outputs:
  jwt-token:
    description: 'Generated JWT token for GitHub App authentication'
runs:
  using: 'composite'
  steps:
    - name: Generate JWT token
      shell: bash
      run: |
        # Install required tools
        if ! command -v jq &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y jq
        fi
        if ! command -v openssl &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y openssl
        fi
        
        APP_ID="${{ inputs.app-id }}"
        PRIVATE_KEY="${{ inputs.private-key }}"
        
        # Generate JWT token
        # JWT format: header.payload.signature
        # Header: {"alg":"RS256","typ":"JWT"}
        # Payload: {"iat":<timestamp>,"exp":<timestamp+10min>,"iss":<APP_ID>}
        
        NOW=$(date +%s)
        EXP=$(($NOW + 600))  # 10 minutes from now
        
        HEADER='{"alg":"RS256","typ":"JWT"}'
        # Payload: iss must be the App ID as a number, not a string
        # Verify App ID is a valid number
        if ! echo "$APP_ID" | grep -qE '^[0-9]+$'; then
          echo "::error::App ID must be a number, got: $APP_ID"
          exit 1
        fi
        
        PAYLOAD=$(jq -n \
          --argjson iat $NOW \
          --argjson exp $EXP \
          --argjson iss $APP_ID \
          '{iat: $iat, exp: $exp, iss: ($iss | tonumber)}')
        
        # Verify payload was created correctly
        if [ -z "$PAYLOAD" ] || [ "$PAYLOAD" = "null" ]; then
          echo "::error::Failed to create JWT payload"
          exit 1
        fi
        
        # Base64 encode (URL-safe, no padding)
        HEADER_B64=$(echo -n "$HEADER" | base64 | tr -d '\n=' | tr '/+' '_-')
        PAYLOAD_B64=$(echo -n "$PAYLOAD" | base64 | tr -d '\n=' | tr '/+' '_-')
        
        # Create signature using the private key
        SIGNATURE_INPUT="${HEADER_B64}.${PAYLOAD_B64}"
        
        # Write private key to temp file for openssl
        TEMP_KEY=$(mktemp)
        echo "$PRIVATE_KEY" > "$TEMP_KEY"
        chmod 600 "$TEMP_KEY"
        
        # Sign and encode
        SIGNATURE=$(echo -n "$SIGNATURE_INPUT" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 | tr -d '\n=' | tr '/+' '_-')
        
        # Clean up
        rm -f "$TEMP_KEY"
        
        JWT_TOKEN="${SIGNATURE_INPUT}.${SIGNATURE}"
        
        # Verify token format
        TOKEN_PARTS=$(echo "$JWT_TOKEN" | tr -cd '.' | wc -c)
        if [ "$TOKEN_PARTS" -ne 2 ]; then
          echo "::error::JWT token format is incorrect (expected 3 parts, found $((TOKEN_PARTS + 1)))"
          exit 1
        fi
        
        # Debug info
        echo "JWT Token generated:"
        echo "  Length: ${#JWT_TOKEN} characters"
        echo "  Format: Valid (3 parts separated by dots)"
        echo "  First 50 chars: ${JWT_TOKEN:0:50}..."
        echo "  Last 10 chars: ...${JWT_TOKEN: -10}"
        
        # Save to output using EOF delimiter to handle special characters
        {
          echo "jwt-token<<EOF"
          echo "$JWT_TOKEN"
          echo "EOF"
        } >> $GITHUB_OUTPUT
        
        echo "::add-mask::$JWT_TOKEN"
        echo "âœ… JWT token generated successfully and saved to output"

