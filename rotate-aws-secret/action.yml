name: 'Rotate AWS Secret'
description: 'Automatically generate a new secure value and update an AWS Secrets Manager secret'
permissions: {}
inputs:
  environment:
    description: 'Environment to use (dev, devops, prod, or stage) - determines which AWS credentials to use'
    required: true
  aws-access-key-id:
    description: 'AWS Access Key ID (use secrets.AWS_ACCESS_KEY_<ENV>)'
    required: true
  aws-secret-access-key:
    description: 'AWS Secret Access Key (use secrets.AWS_SECRET_KEY_<ENV>)'
    required: true
  aws-region:
    description: 'AWS Region'
    required: false
    default: 'us-east-1'
  secret-arn:
    description: 'ARN of the AWS secret to rotate'
    required: true
  secret-key:
    description: 'Key name to update in JSON secret. The secret will be treated as JSON and only this key will be updated, preserving other keys.'
    required: true
  new-secret-value:
    description: 'The secret value to use for updating the JSON key. Must be provided by the caller.'
    required: true
outputs:
  success:
    description: 'Whether the secret was rotated successfully'
    value: ${{ steps.rotate-secret.outputs.success }}
  secret-arn:
    description: 'ARN of the secret that was rotated'
    value: ${{ steps.rotate-secret.outputs.secret-arn }}
  version-id:
    description: 'Version ID of the rotated secret'
    value: ${{ steps.rotate-secret.outputs.version-id }}
  new-secret-value:
    description: 'The newly generated secret value (masked in logs)'
    value: ${{ steps.rotate-secret.outputs.new-secret-value }}
runs:
  using: 'composite'
  steps:
    - name: Rotate AWS secret
      id: rotate-secret
      shell: bash
      run: |
        set -e
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Rotating AWS Secrets Manager Secret"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # Install AWS CLI if not available
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install
          rm -rf awscliv2.zip aws
        fi
        
        # Install jq if not available
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
        
        ENVIRONMENT="${{ inputs.environment }}"
        AWS_ACCESS_KEY_ID="${{ inputs.aws-access-key-id }}"
        AWS_SECRET_ACCESS_KEY="${{ inputs.aws-secret-access-key }}"
        AWS_REGION="${{ inputs.aws-region }}"
        SECRET_ARN="${{ inputs.secret-arn }}"
        SECRET_KEY="${{ inputs.secret-key }}"
        PROVIDED_SECRET_VALUE="${{ inputs.new-secret-value }}"
        
        # Validate secret-key is provided
        if [ -z "$SECRET_KEY" ]; then
          echo "::error::Secret key is required. This action updates a specific key in a JSON secret."
          exit 1
        fi
        
        # Validate environment parameter
        echo ""
        echo "Input validation:"
        if [ -z "$ENVIRONMENT" ]; then
          echo "::error::Environment is empty or not set"
          exit 1
        fi
        
        # Validate environment is one of the allowed values
        case "$ENVIRONMENT" in
          dev|devops|prod|stage)
            echo "  ✓ Environment: $ENVIRONMENT"
            ;;
          *)
            echo "::error::Invalid environment '$ENVIRONMENT'. Must be one of: dev, devops, prod, stage"
            exit 1
            ;;
        esac
        
        # Convert environment to uppercase for logging
        ENV_UPPER=$(echo "$ENVIRONMENT" | tr '[:lower:]' '[:upper:]')
        
        # Validate AWS credentials
        if [ -z "$AWS_ACCESS_KEY_ID" ]; then
          echo "::error::AWS Access Key ID is empty or not set"
          echo "Make sure you're passing secrets.AWS_ACCESS_KEY_${ENV_UPPER}"
          exit 1
        fi
        echo "  ✓ AWS Access Key ID: Set (length: ${#AWS_ACCESS_KEY_ID})"
        
        if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
          echo "::error::AWS Secret Access Key is empty or not set"
          echo "Make sure you're passing secrets.AWS_SECRET_KEY_${ENV_UPPER}"
          exit 1
        fi
        echo "  ✓ AWS Secret Access Key: Set (length: ${#AWS_SECRET_ACCESS_KEY} characters)"
        
        if [ -z "$SECRET_ARN" ]; then
          echo "::error::Secret ARN is empty or not set"
          exit 1
        fi
        echo "  ✓ Secret ARN: $SECRET_ARN"
        echo "  ✓ AWS Region: $AWS_REGION"
        echo "  ✓ Secret Key (JSON): $SECRET_KEY (will update only this key in JSON)"
        echo ""
        
        # Validate new-secret-value is provided
        if [ -z "$PROVIDED_SECRET_VALUE" ]; then
          echo "::error::new-secret-value is required. The caller must generate and provide the secret value."
          exit 1
        fi
        
        # Configure AWS credentials
        export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
        export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
        export AWS_DEFAULT_REGION="$AWS_REGION"
        
        # Use provided secret value
        NEW_SECRET="$PROVIDED_SECRET_VALUE"
        echo "✓ Using provided secret value (length: ${#NEW_SECRET})"
        
        # Mask the new secret in logs
        echo "::add-mask::$NEW_SECRET"
        echo "::add-mask::$AWS_ACCESS_KEY_ID"
        echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
        
        # Always update a specific key in JSON secret
        echo ""
        echo "Updating key '$SECRET_KEY' in JSON secret..."
        echo "Process: Download JSON → Update key → Save JSON"
        
        # Step 1: Get current secret value from AWS
        echo ""
        echo "Step 1: Retrieving current secret from AWS..."
        CURRENT_SECRET_RESPONSE=$(aws secretsmanager get-secret-value \
          --secret-id "$SECRET_ARN" \
          --region "$AWS_REGION" \
          --output json 2>&1) || {
          echo "::error::Failed to retrieve current secret from AWS"
          echo "$CURRENT_SECRET_RESPONSE"
          exit 1
        }
        
        CURRENT_SECRET_STRING=$(echo "$CURRENT_SECRET_RESPONSE" | jq -r '.SecretString // empty')
        
        if [ -z "$CURRENT_SECRET_STRING" ]; then
          echo "::error::Current secret value is empty or not found"
          exit 1
        fi
        
        echo "✓ Retrieved current secret from AWS"
        
        # Step 2: Parse as JSON (or create new JSON if not valid)
        echo ""
        echo "Step 2: Parsing secret as JSON..."
        if echo "$CURRENT_SECRET_STRING" | jq empty 2>/dev/null; then
          echo "✓ Current secret is valid JSON"
          SECRET_JSON="$CURRENT_SECRET_STRING"
        else
          echo "⚠️  Current secret is not valid JSON, creating new JSON structure"
          SECRET_JSON="{}"
        fi
        
        # Step 3: Update or create the key in JSON
        echo ""
        echo "Step 3: Updating key '$SECRET_KEY' in JSON..."
        UPDATED_JSON=$(echo "$SECRET_JSON" | jq --arg key "$SECRET_KEY" --arg value "$NEW_SECRET" '.[$key] = $value')
        
        # Verify the update
        UPDATED_VALUE=$(echo "$UPDATED_JSON" | jq -r --arg key "$SECRET_KEY" '.[$key] // empty')
        if [ "$UPDATED_VALUE" != "$NEW_SECRET" ]; then
          echo "::error::Failed to update key in JSON"
          exit 1
        fi
        
        echo "✓ Key '$SECRET_KEY' updated in JSON"
        
        # Step 4: Save the updated JSON back to AWS
        echo ""
        echo "Step 4: Saving updated JSON to AWS Secrets Manager..."
        RESPONSE=$(aws secretsmanager put-secret-value \
          --secret-id "$SECRET_ARN" \
          --secret-string "$UPDATED_JSON" \
          --region "$AWS_REGION" \
          --output json 2>&1) || UPDATE_EXIT_CODE=$?
        
        if [ ${UPDATE_EXIT_CODE:-0} -eq 0 ]; then
          # Parse response
          VERSION_ID=$(echo "$RESPONSE" | jq -r '.VersionId // empty')
          SECRET_ARN_RESPONSE=$(echo "$RESPONSE" | jq -r '.ARN // empty')
          
          echo "success=true" >> $GITHUB_OUTPUT
          echo "secret-arn=$SECRET_ARN_RESPONSE" >> $GITHUB_OUTPUT
          
          # Save the new secret value to output (masked)
          {
            echo "new-secret-value<<EOF"
            echo "$NEW_SECRET"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          if [ -n "$VERSION_ID" ] && [ "$VERSION_ID" != "null" ]; then
            echo "version-id=$VERSION_ID" >> $GITHUB_OUTPUT
            echo "  ✓ Version ID: $VERSION_ID"
          fi
          
          echo ""
          echo "✅ Successfully rotated AWS secret"
          echo "  Secret ARN: $SECRET_ARN_RESPONSE"
          echo "  New secret length: ${#NEW_SECRET} characters"
          echo ""
          echo "⚠️  IMPORTANT: The new secret value is available in the 'new-secret-value' output"
          echo "    Use it to update other services that depend on this secret."
        else
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::error::Failed to rotate AWS secret"
          echo "Error response: $RESPONSE"
          echo ""
          echo "Common issues:"
          echo "  - Invalid AWS credentials"
          echo "  - Insufficient IAM permissions (needs secretsmanager:PutSecretValue)"
          echo "  - Secret ARN does not exist or is in a different region"
          echo "  - Secret is scheduled for deletion"
          exit 1
        fi
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

