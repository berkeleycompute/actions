name: 'Get GitHub App Installation Token'
description: 'Generate JWT and get installation access token in one step'
permissions: {}
inputs:
  app-id:
    description: 'GitHub App ID (required - provide via input or set GH_APP_ID env var/secret)'
    required: false
  private-key:
    description: 'GitHub App private key in PEM format (required - provide via input or set GH_APP_PRIVATE_KEY env var/secret)'
    required: false
  installation-id:
    description: 'GitHub App installation ID (required - provide via input or set GH_APP_INSTALLATION_ID env var/secret)'
    required: false
outputs:
  token:
    description: 'Installation access token'
    value: ${{ steps.generate-token.outputs.token }}
  expires-at:
    description: 'Token expiration timestamp'
    value: ${{ steps.generate-token.outputs.expires-at }}
runs:
  using: 'composite'
  steps:
    - name: Generate JWT and get installation token
      id: generate-token
      shell: bash
      run: |
        set -e
        
        echo "üîç DEBUG: Running get-github-app-token action (commit: 120822f - 2024-12-16)"
        
        # Install required tools
        if ! command -v jq &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y jq
        fi
        if ! command -v openssl &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y openssl
        fi
        if ! command -v curl &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y curl
        fi
        
        # Get values from inputs, then fall back to environment variables/secrets
        APP_ID="${{ inputs.app-id }}"
        if [ -z "$APP_ID" ]; then
          APP_ID="${GH_APP_ID:-}"
        fi
        
        PRIVATE_KEY="${{ inputs.private-key }}"
        if [ -z "$PRIVATE_KEY" ]; then
          PRIVATE_KEY="${GH_APP_PRIVATE_KEY:-}"
        fi
        
        INSTALLATION_ID="${{ inputs.installation-id }}"
        if [ -z "$INSTALLATION_ID" ]; then
          INSTALLATION_ID="${GH_APP_INSTALLATION_ID:-}"
        fi
        
        # Validate all required values are present (must be provided via input or env var)
        if [ -z "$APP_ID" ]; then
          echo "::error::App ID is REQUIRED but not provided"
          echo "Provide it via:"
          echo "  - Input: app-id: \${{ secrets.GH_APP_ID }}"
          echo "  - Environment variable: GH_APP_ID"
          exit 1
        fi
        
        if [ -z "$PRIVATE_KEY" ]; then
          echo "::error::Private key is REQUIRED but not provided"
          echo "Provide it via:"
          echo "  - Input: private-key: \${{ secrets.GH_APP_PRIVATE_KEY }}"
          echo "  - Environment variable: GH_APP_PRIVATE_KEY"
          exit 1
        fi
        
        if [ -z "$INSTALLATION_ID" ]; then
          echo "::error::Installation ID is REQUIRED but not provided"
          echo "Provide it via:"
          echo "  - Input: installation-id: \${{ secrets.GH_APP_INSTALLATION_ID }}"
          echo "  - Environment variable: GH_APP_INSTALLATION_ID"
          exit 1
        fi
        
        # Generate JWT token
        NOW=$(date +%s)
        EXP=$(($NOW + 600))  # 10 minutes from now
        
        HEADER='{"alg":"RS256","typ":"JWT"}'
        PAYLOAD=$(jq -n \
          --argjson iat $NOW \
          --argjson exp $EXP \
          --argjson iss $APP_ID \
          '{iat: $iat, exp: $exp, iss: ($iss | tonumber)}')
        
        # Base64 encode (URL-safe, no padding)
        HEADER_B64=$(echo -n "$HEADER" | base64 | tr -d '\n=' | tr '/+' '_-')
        PAYLOAD_B64=$(echo -n "$PAYLOAD" | base64 | tr -d '\n=' | tr '/+' '_-')
        
        # Create signature using the private key
        SIGNATURE_INPUT="${HEADER_B64}.${PAYLOAD_B64}"
        
        # Write private key to temp file for openssl
        TEMP_KEY=$(mktemp)
        echo "$PRIVATE_KEY" > "$TEMP_KEY"
        chmod 600 "$TEMP_KEY"
        
        # Sign and encode
        SIGNATURE=$(echo -n "$SIGNATURE_INPUT" | openssl dgst -sha256 -sign "$TEMP_KEY" -binary | base64 | tr -d '\n=' | tr '/+' '_-')
        
        # Clean up
        rm -f "$TEMP_KEY"
        
        JWT_TOKEN="${SIGNATURE_INPUT}.${SIGNATURE}"
        
        # Get installation access token using JWT
        API_URL="https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens"
        
        RESPONSE=$(curl -s -w "\n%{http_code}" \
          -X POST \
          -H "Authorization: Bearer $JWT_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "$API_URL")
        
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        
        if [ "$HTTP_CODE" != "201" ]; then
          echo "::error::Failed to generate installation token (HTTP $HTTP_CODE)"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
        
        # Parse JSON response
        TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.token // empty')
        EXPIRES_AT=$(echo "$RESPONSE_BODY" | jq -r '.expires_at // empty')
        
        if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
          echo "::error::Token not found in response"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
        
        # Save to outputs
        echo "üîç DEBUG: Writing token to GITHUB_OUTPUT: $GITHUB_OUTPUT"
        echo "üîç DEBUG: Token value present: ${#TOKEN} characters"
        {
          echo "token<<EOF"
          echo "$TOKEN"
          echo "EOF"
        } >> $GITHUB_OUTPUT
        
        echo "üîç DEBUG: Verifying output was written..."
        if grep -q "^token<<EOF" "$GITHUB_OUTPUT"; then
          echo "‚úÖ DEBUG: token<<EOF found in output file"
        else
          echo "‚ùå DEBUG: token<<EOF NOT found in output file"
        fi
        
        if [ -n "$EXPIRES_AT" ] && [ "$EXPIRES_AT" != "null" ]; then
          echo "expires-at=$EXPIRES_AT" >> $GITHUB_OUTPUT
        fi
        
        echo "::add-mask::$TOKEN"
        echo "‚úÖ Successfully generated installation access token"
        echo "Token length: ${#TOKEN} characters"
        if [ -n "$EXPIRES_AT" ] && [ "$EXPIRES_AT" != "null" ]; then
          echo "Token expires at: $EXPIRES_AT"
        fi

