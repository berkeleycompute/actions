name: 'Rotate AWS Access Key'
description: 'Rotate AWS IAM access keys by creating a new key and deleting the old one'
inputs:
  environment:
    description: 'Environment to use (dev, devops, prod, or stage) - determines which AWS credentials to use'
    required: true
  aws-access-key-id:
    description: 'AWS Access Key ID (use secrets.AWS_ACCESS_KEY_<ENV>)'
    required: true
  aws-secret-access-key:
    description: 'AWS Secret Access Key (use secrets.AWS_SECRET_KEY_<ENV>)'
    required: true
  aws-region:
    description: 'AWS Region'
    required: false
    default: 'us-east-1'
  iam-username:
    description: 'IAM username whose access key will be rotated'
    required: true
  update-github-secrets:
    description: 'Whether to automatically update GitHub organization secrets with new credentials (requires github-pat)'
    required: false
    default: 'false'
  github-pat:
    description: 'GitHub Personal Access Token with admin:org permissions (required if update-github-secrets is true)'
    required: false
  github-org:
    description: 'GitHub organization name (defaults to repository owner if not provided)'
    required: false
outputs:
  success:
    description: 'Whether the access key was rotated successfully'
    value: ${{ steps.rotate-key.outputs.success }}
  new-access-key-id:
    description: 'The newly created access key ID (masked in logs)'
    value: ${{ steps.rotate-key.outputs.new-access-key-id }}
  new-secret-access-key:
    description: 'The newly created secret access key (masked in logs)'
    value: ${{ steps.rotate-key.outputs.new-secret-access-key }}
  old-access-key-id:
    description: 'The old access key ID that was deleted'
    value: ${{ steps.rotate-key.outputs.old-access-key-id }}
runs:
  using: 'composite'
  steps:
    - name: Rotate AWS access key
      id: rotate-key
      shell: bash
      run: |
        set -e
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Rotating AWS IAM Access Key"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # Install AWS CLI if not available
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install
          rm -rf awscliv2.zip aws
        fi
        
        # Install jq if not available
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
        
        ENVIRONMENT="${{ inputs.environment }}"
        AWS_ACCESS_KEY_ID="${{ inputs.aws-access-key-id }}"
        AWS_SECRET_ACCESS_KEY="${{ inputs.aws-secret-access-key }}"
        AWS_REGION="${{ inputs.aws-region }}"
        IAM_USERNAME="${{ inputs.iam-username }}"
        
        # Validate environment parameter
        echo ""
        echo "Input validation:"
        if [ -z "$ENVIRONMENT" ]; then
          echo "::error::Environment is empty or not set"
          exit 1
        fi
        
        # Validate environment is one of the allowed values
        case "$ENVIRONMENT" in
          dev|devops|prod|stage)
            echo "  ✓ Environment: $ENVIRONMENT"
            ;;
          *)
            echo "::error::Invalid environment '$ENVIRONMENT'. Must be one of: dev, devops, prod, stage"
            exit 1
            ;;
        esac
        
        # Convert environment to uppercase for logging
        ENV_UPPER=$(echo "$ENVIRONMENT" | tr '[:lower:]' '[:upper:]')
        
        # Validate AWS credentials
        if [ -z "$AWS_ACCESS_KEY_ID" ]; then
          echo "::error::AWS Access Key ID is empty or not set"
          echo "Make sure you're passing secrets.AWS_ACCESS_KEY_${ENV_UPPER}"
          exit 1
        fi
        echo "  ✓ AWS Access Key ID: Set (length: ${#AWS_ACCESS_KEY_ID})"
        
        if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
          echo "::error::AWS Secret Access Key is empty or not set"
          echo "Make sure you're passing secrets.AWS_SECRET_KEY_${ENV_UPPER}"
          exit 1
        fi
        echo "  ✓ AWS Secret Access Key: Set (length: ${#AWS_SECRET_ACCESS_KEY} characters)"
        
        if [ -z "$IAM_USERNAME" ]; then
          echo "::error::IAM username is empty or not set"
          exit 1
        fi
        echo "  ✓ IAM Username: $IAM_USERNAME"
        echo "  ✓ AWS Region: $AWS_REGION"
        echo ""
        
        # Configure AWS credentials
        export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
        export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
        export AWS_DEFAULT_REGION="$AWS_REGION"
        
        # Mask sensitive values in logs
        echo "::add-mask::$AWS_ACCESS_KEY_ID"
        echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
        
        # Step 1: List current access keys
        echo ""
        echo "Step 1: Listing current access keys for user '$IAM_USERNAME'..."
        LIST_KEYS_RESPONSE=$(aws iam list-access-keys \
          --user-name "$IAM_USERNAME" \
          --output json 2>&1) || {
          echo "::error::Failed to list access keys for user '$IAM_USERNAME'"
          echo "$LIST_KEYS_RESPONSE"
          exit 1
        }
        
        # Parse existing keys
        EXISTING_KEYS=$(echo "$LIST_KEYS_RESPONSE" | jq -r '.AccessKeyMetadata // []')
        KEY_COUNT=$(echo "$EXISTING_KEYS" | jq 'length')
        
        echo "  ✓ Found $KEY_COUNT access key(s) for user '$IAM_USERNAME'"
        
        if [ "$KEY_COUNT" -eq 0 ]; then
          echo "::error::No existing access keys found for user '$IAM_USERNAME'. Cannot rotate."
          exit 1
        fi
        
        # Find the access key ID that matches the one being used for authentication
        # This is the key we want to replace (delete after creating new one)
        OLD_ACCESS_KEY_ID=""
        for i in $(seq 0 $((KEY_COUNT - 1))); do
          KEY_ID=$(echo "$EXISTING_KEYS" | jq -r ".[$i].AccessKeyId")
          if [ "$KEY_ID" = "$AWS_ACCESS_KEY_ID" ]; then
            OLD_ACCESS_KEY_ID="$KEY_ID"
            break
          fi
        done
        
        # If we didn't find the auth key in the list, use the first one as fallback
        if [ -z "$OLD_ACCESS_KEY_ID" ] || [ "$OLD_ACCESS_KEY_ID" = "null" ]; then
          echo "⚠️  WARNING: The access key used for authentication ($AWS_ACCESS_KEY_ID) was not found in the user's key list."
          echo "    Using the first key in the list as the key to delete."
          OLD_ACCESS_KEY_ID=$(echo "$EXISTING_KEYS" | jq -r '.[0].AccessKeyId // empty')
          if [ -z "$OLD_ACCESS_KEY_ID" ] || [ "$OLD_ACCESS_KEY_ID" = "null" ]; then
            echo "::error::Could not extract access key ID from response"
            exit 1
          fi
        fi
        
        echo "  ✓ Current Access Key ID (to be replaced): $OLD_ACCESS_KEY_ID"
        
        # Check if we're trying to delete the key we're currently using
        if [ "$OLD_ACCESS_KEY_ID" = "$AWS_ACCESS_KEY_ID" ]; then
          echo "⚠️  WARNING: The access key being used for authentication is the one that will be deleted."
          echo "    This is expected during rotation, but ensure the new key is saved before deletion."
        fi
        
        # Step 1.5: If there are multiple keys, delete the unused ones first
        if [ "$KEY_COUNT" -ge 2 ]; then
          echo ""
          echo "Step 1.5: Cleaning up unused access keys..."
          echo "  User '$IAM_USERNAME' has $KEY_COUNT access key(s) (AWS limit is 2)."
          echo "  Existing keys:"
          echo "$EXISTING_KEYS" | jq -r '.[] | "    - \(.AccessKeyId) (Status: \(.Status), Created: \(.CreateDate))"'
          echo ""
          echo "  Deleting unused key(s) (not the one used for authentication)..."
          
          # Find and delete all keys that are NOT the one being used for authentication
          DELETED_COUNT=0
          for i in $(seq 0 $((KEY_COUNT - 1))); do
            KEY_ID=$(echo "$EXISTING_KEYS" | jq -r ".[$i].AccessKeyId")
            if [ "$KEY_ID" != "$AWS_ACCESS_KEY_ID" ]; then
              echo "    Deleting unused access key: $KEY_ID"
              DELETE_UNUSED_RESPONSE=$(aws iam delete-access-key \
                --user-name "$IAM_USERNAME" \
                --access-key-id "$KEY_ID" \
                --output json 2>&1) || {
                DELETE_UNUSED_EXIT_CODE=$?
                echo "::error::Failed to delete unused access key '$KEY_ID' (exit code: $DELETE_UNUSED_EXIT_CODE)"
                echo "Response: $DELETE_UNUSED_RESPONSE"
                exit 1
              }
              echo "      ✓ Successfully deleted unused access key '$KEY_ID'"
              DELETED_COUNT=$((DELETED_COUNT + 1))
            fi
          done
          
          if [ $DELETED_COUNT -eq 0 ]; then
            echo "::error::Could not find any unused access keys to delete."
            echo "    All existing keys match the authentication key, or key extraction failed."
            exit 1
          fi
          
          echo "  ✓ Deleted $DELETED_COUNT unused access key(s)"
          echo ""
          echo "  Waiting for AWS to process the deletion (5 seconds)..."
          sleep 5
          
          # Verify that only the current key remains
          echo "  Verifying that only the current key remains..."
          MAX_VERIFY_RETRIES=5
          VERIFY_RETRY_COUNT=0
          VERIFY_SUCCESS=false
          
          while [ $VERIFY_RETRY_COUNT -lt $MAX_VERIFY_RETRIES ]; do
            VERIFY_RETRY_COUNT=$((VERIFY_RETRY_COUNT + 1))
            VERIFY_LIST_RESPONSE=$(aws iam list-access-keys \
              --user-name "$IAM_USERNAME" \
              --output json 2>&1) || {
              echo "    ⚠️  Warning: Failed to verify keys (attempt $VERIFY_RETRY_COUNT/$MAX_VERIFY_RETRIES)"
              if [ $VERIFY_RETRY_COUNT -lt $MAX_VERIFY_RETRIES ]; then
                sleep 2
                continue
              else
                echo "::error::Failed to verify keys after deletion"
                exit 1
              fi
            }
            
            VERIFY_KEYS=$(echo "$VERIFY_LIST_RESPONSE" | jq -r '.AccessKeyMetadata // []')
            VERIFY_KEY_COUNT=$(echo "$VERIFY_KEYS" | jq 'length')
            
            if [ "$VERIFY_KEY_COUNT" -eq 1 ]; then
              VERIFY_KEY_ID=$(echo "$VERIFY_KEYS" | jq -r '.[0].AccessKeyId')
              if [ "$VERIFY_KEY_ID" = "$AWS_ACCESS_KEY_ID" ]; then
                echo "    ✓ Verified: Only the current access key remains ($VERIFY_KEY_ID)"
                VERIFY_SUCCESS=true
                break
              else
                echo "    ⚠️  Warning: Only one key remains, but it's not the expected one (attempt $VERIFY_RETRY_COUNT/$MAX_VERIFY_RETRIES)"
                if [ $VERIFY_RETRY_COUNT -lt $MAX_VERIFY_RETRIES ]; then
                  sleep 2
                  continue
                fi
              fi
            else
              echo "    ⚠️  Warning: Still $VERIFY_KEY_COUNT key(s) remaining (expected 1) (attempt $VERIFY_RETRY_COUNT/$MAX_VERIFY_RETRIES)"
              if [ $VERIFY_RETRY_COUNT -lt $MAX_VERIFY_RETRIES ]; then
                sleep 2
                continue
              fi
            fi
          done
          
          if [ "$VERIFY_SUCCESS" != "true" ]; then
            echo "::error::Verification failed: Expected only 1 key (the current one), but found $VERIFY_KEY_COUNT key(s)"
            echo "    Remaining keys:"
            echo "$VERIFY_KEYS" | jq -r '.[] | "      - \(.AccessKeyId)"'
            exit 1
          fi
          
          echo ""
          echo "  ✅ Cleanup complete. Only the current access key remains. Proceeding with rotation..."
        fi
        
        # Step 2: Create new access key
        echo ""
        echo "Step 2: Creating new access key for user '$IAM_USERNAME'..."
        
        # Create new access key
        # Note: The --use-case parameter is not available in all AWS CLI versions
        # Access keys created here are intended for CLI/API usage
        CREATE_KEY_RESPONSE=$(aws iam create-access-key \
          --user-name "$IAM_USERNAME" \
          --output json 2>&1) || {
          echo "::error::Failed to create new access key for user '$IAM_USERNAME'"
          echo "$CREATE_KEY_RESPONSE"
          exit 1
        }
        
        # Parse new key details
        NEW_ACCESS_KEY_ID=$(echo "$CREATE_KEY_RESPONSE" | jq -r '.AccessKey.AccessKeyId // empty')
        NEW_SECRET_ACCESS_KEY=$(echo "$CREATE_KEY_RESPONSE" | jq -r '.AccessKey.SecretAccessKey // empty')
        
        if [ -z "$NEW_ACCESS_KEY_ID" ] || [ "$NEW_ACCESS_KEY_ID" = "null" ]; then
          echo "::error::Failed to extract new access key ID from response"
          echo "Full response: $CREATE_KEY_RESPONSE"
          exit 1
        fi
        
        if [ -z "$NEW_SECRET_ACCESS_KEY" ] || [ "$NEW_SECRET_ACCESS_KEY" = "null" ]; then
          echo "::error::Failed to extract new secret access key from response"
          echo "Full response: $CREATE_KEY_RESPONSE"
          exit 1
        fi
        
        # Clean the secret access key (remove any newlines or extra whitespace)
        NEW_SECRET_ACCESS_KEY=$(echo "$NEW_SECRET_ACCESS_KEY" | tr -d '\n\r' | xargs)
        
        echo "  ✓ New Access Key ID: $NEW_ACCESS_KEY_ID"
        echo "  ✓ New Secret Access Key: Set (length: ${#NEW_SECRET_ACCESS_KEY} characters)"
        
        # Mask the new keys in logs
        echo "::add-mask::$NEW_ACCESS_KEY_ID"
        echo "::add-mask::$NEW_SECRET_ACCESS_KEY"
        
        # Note: AWS CLI doesn't support --use-case parameter (this is a console-only feature)
        # The access key is created for CLI/API usage by default
        # If you need to specify a use case, you can do so manually in the AWS Console after creation
        echo "  ℹ️  Note: Access key created for CLI/API usage"
        echo "    (Use case specification is only available in AWS Console, not CLI)"
        
        # Step 3: Test the new access key
        echo ""
        echo "Step 3: Testing new access key..."
        echo "  Waiting 5 seconds for AWS to propagate the new key..."
        sleep 5
        
        # Debug: Verify the credentials are set correctly
        echo "  Debug: Verifying credentials before test..."
        echo "    New Access Key ID length: ${#NEW_ACCESS_KEY_ID}"
        echo "    New Secret Access Key length: ${#NEW_SECRET_ACCESS_KEY}"
        
        # Test the new key by creating a temporary session
        # Try multiple times with increasing delays (AWS may need time to propagate)
        echo "  Testing new key with AWS STS GetCallerIdentity..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        TEST_IDENTITY=""
        TEST_EXIT_CODE=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "    Attempt $RETRY_COUNT of $MAX_RETRIES..."
          
          # Use explicit export to ensure variables are set correctly
          export AWS_ACCESS_KEY_ID="$NEW_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$NEW_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="$AWS_REGION"
          
          # Test with explicit credentials
          TEST_IDENTITY=$(aws sts get-caller-identity \
            --output json 2>&1) && {
            echo "    ✓ Success on attempt $RETRY_COUNT"
            break
          } || {
            TEST_EXIT_CODE=$?
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 2))
              echo "    ✗ Attempt $RETRY_COUNT failed (exit code: $TEST_EXIT_CODE), waiting ${WAIT_TIME}s before retry..."
              sleep $WAIT_TIME
            else
              echo "    ✗ All attempts failed"
            fi
          }
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ] && [ $TEST_EXIT_CODE -ne 0 ]; then
          echo "::error::Failed to verify new access key after $MAX_RETRIES attempts (exit code: $TEST_EXIT_CODE)"
          echo "Last response: $TEST_IDENTITY"
          echo ""
          echo "Debug information:"
          echo "  - Access Key ID: $NEW_ACCESS_KEY_ID"
          echo "  - Secret Access Key length: ${#NEW_SECRET_ACCESS_KEY}"
          echo "  - Region: $AWS_REGION"
          echo ""
          echo "Trying manual verification with explicit credentials..."
          # Try one more time with explicit credentials in the command
          MANUAL_TEST=$(AWS_ACCESS_KEY_ID="$NEW_ACCESS_KEY_ID" \
            AWS_SECRET_ACCESS_KEY="$NEW_SECRET_ACCESS_KEY" \
            AWS_DEFAULT_REGION="$AWS_REGION" \
            aws sts get-caller-identity --output json 2>&1) || {
            echo "Manual test also failed:"
            echo "$MANUAL_TEST"
            echo ""
            echo "⚠️  WARNING: New access key was created but verification failed!"
            echo "    New Access Key ID: $NEW_ACCESS_KEY_ID"
            echo "    New Secret Access Key: $NEW_SECRET_ACCESS_KEY"
            echo "    Old Access Key ID (still active): $OLD_ACCESS_KEY_ID"
            echo ""
            echo "    The new key will NOT be deleted. You should:"
            echo "    1. Manually verify the new key"
            echo "    2. If the new key works, manually delete the old key: $OLD_ACCESS_KEY_ID"
            echo "    3. If the new key doesn't work, delete it and investigate the issue"
            echo ""
            echo "    To delete the new key if needed:"
            echo "    aws iam delete-access-key --user-name $IAM_USERNAME --access-key-id $NEW_ACCESS_KEY_ID"
            exit 1
          }
          TEST_IDENTITY="$MANUAL_TEST"
          echo "  ✓ Manual test succeeded!"
        fi
        
        # Verify the test response
        TEST_USER_ARN=$(echo "$TEST_IDENTITY" | jq -r '.Arn // empty')
        TEST_USER_ID=$(echo "$TEST_IDENTITY" | jq -r '.UserId // empty')
        TEST_ACCOUNT=$(echo "$TEST_IDENTITY" | jq -r '.Account // empty')
        
        if [ -z "$TEST_USER_ARN" ] || [ "$TEST_USER_ARN" = "null" ]; then
          echo "::error::New access key verification returned invalid response"
          echo "Response: $TEST_IDENTITY"
          echo ""
          echo "⚠️  WARNING: New access key was created but verification failed!"
          echo "    The new key will NOT be deleted. Please verify manually."
          exit 1
        fi
        
        echo "  ✓ New access key verified successfully!"
        echo "    User ARN: $TEST_USER_ARN"
        echo "    User ID: $TEST_USER_ID"
        echo "    Account: $TEST_ACCOUNT"
        echo ""
        echo "  ✅ New key is working correctly. Proceeding to delete old key..."
        
        # Step 4: Delete old access key (only if new key works)
        echo ""
        echo "Step 4: Deleting old access key '$OLD_ACCESS_KEY_ID'..."
        
        # Use the new key credentials to delete the old key (in case old key was used for auth)
        # If the old key was used for authentication, we need to use the new key for deletion
        DELETE_KEY_RESPONSE=$(AWS_ACCESS_KEY_ID="$NEW_ACCESS_KEY_ID" \
          AWS_SECRET_ACCESS_KEY="$NEW_SECRET_ACCESS_KEY" \
          AWS_DEFAULT_REGION="$AWS_REGION" \
          aws iam delete-access-key \
          --user-name "$IAM_USERNAME" \
          --access-key-id "$OLD_ACCESS_KEY_ID" \
          --output json 2>&1) || {
          DELETE_EXIT_CODE=$?
          echo "::error::Failed to delete old access key '$OLD_ACCESS_KEY_ID' (exit code: $DELETE_EXIT_CODE)"
          echo "Response: $DELETE_KEY_RESPONSE"
          echo ""
          echo "⚠️  WARNING: New access key was created and verified, but old key deletion failed!"
          echo "    New Access Key ID: $NEW_ACCESS_KEY_ID"
          echo "    New Secret Access Key: $NEW_SECRET_ACCESS_KEY"
          echo "    Old Access Key ID (still active): $OLD_ACCESS_KEY_ID"
          echo ""
          echo "    The new key is working correctly. You should manually delete the old key:"
          echo "    aws iam delete-access-key --user-name $IAM_USERNAME --access-key-id $OLD_ACCESS_KEY_ID"
          echo ""
          echo "    Or retry this action."
          exit 1
        }
        
        echo "  ✓ Successfully deleted old access key '$OLD_ACCESS_KEY_ID'"
        
        # Set outputs
        echo "success=true" >> $GITHUB_OUTPUT
        echo "new-access-key-id=$NEW_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
        echo "old-access-key-id=$OLD_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
        
        # Save the new secret access key to output (masked)
        {
          echo "new-secret-access-key<<EOF"
          echo "$NEW_SECRET_ACCESS_KEY"
          echo "EOF"
        } >> $GITHUB_OUTPUT
        
        echo ""
        echo "✅ Successfully rotated AWS access key for user '$IAM_USERNAME'"
        echo "  Old Access Key ID (deleted): $OLD_ACCESS_KEY_ID"
        echo "  New Access Key ID: $NEW_ACCESS_KEY_ID"
        echo ""
        echo "  Rotation process:"
        echo "    1. ✓ Created new access key"
        echo "    2. ✓ Verified new access key works (tested with AWS STS)"
        echo "    3. ✓ Deleted old access key (only after verification succeeded)"
        echo ""
        echo "⚠️  IMPORTANT: Save the new access key credentials immediately!"
        echo "    New Access Key ID: $NEW_ACCESS_KEY_ID"
        echo "    New Secret Access Key: Available in the 'new-secret-access-key' output"
        echo ""
        echo "    Update all services and configurations that use the old key."
        echo "    The old key '$OLD_ACCESS_KEY_ID' has been deleted and is no longer valid."
        echo ""
        
        # Step 5: Update GitHub organization secrets (optional)
        UPDATE_SECRETS="${{ inputs.update-github-secrets }}"
        GITHUB_PAT="${{ inputs.github-pat }}"
        GITHUB_ORG="${{ inputs.github-org }}"
        
        if [ "$UPDATE_SECRETS" = "true" ] || [ "$UPDATE_SECRETS" = "True" ] || [ "$UPDATE_SECRETS" = "TRUE" ]; then
          echo ""
          echo "Step 5: Updating GitHub organization secrets..."
          
          if [ -z "$GITHUB_PAT" ] || [ "$GITHUB_PAT" = "" ]; then
            echo "  ⚠️  Warning: update-github-secrets is true but github-pat is not provided"
            echo "    Skipping GitHub secrets update."
            echo "    To enable automatic updates, provide a PAT with admin:org permissions."
          else
            # Install GitHub CLI if not available
            if ! command -v gh &> /dev/null; then
              echo "  Installing GitHub CLI..."
              type -p curl >/dev/null || (sudo apt-get update && sudo apt-get install curl -y)
              curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
              sudo apt-get update
              sudo apt-get install -y gh
            fi
            
            # Determine organization name
            if [ -z "$GITHUB_ORG" ] || [ "$GITHUB_ORG" = "" ]; then
              # Try to get from environment (if running in GitHub Actions)
              if [ -n "$GITHUB_REPOSITORY_OWNER" ]; then
                GITHUB_ORG="$GITHUB_REPOSITORY_OWNER"
              else
                echo "  ⚠️  Warning: github-org not provided and GITHUB_REPOSITORY_OWNER not available"
                echo "    Skipping GitHub secrets update."
                GITHUB_ORG=""
              fi
            fi
            
            if [ -n "$GITHUB_ORG" ] && [ "$GITHUB_ORG" != "" ]; then
              # Unset default GITHUB_TOKEN
              unset GITHUB_TOKEN
              
              # Authenticate with PAT
              echo "  Authenticating with GitHub CLI..."
              echo "$GITHUB_PAT" | gh auth login --with-token 2>&1 || {
                echo "  ⚠️  Warning: Failed to authenticate with GitHub CLI"
                echo "    Skipping GitHub secrets update."
                GITHUB_ORG=""
              }
              
              if [ -n "$GITHUB_ORG" ] && [ "$GITHUB_ORG" != "" ]; then
                # Convert environment to uppercase for secret names
                ENV_UPPER=$(echo "$ENVIRONMENT" | tr '[:lower:]' '[:upper:]')
                
                echo "  Updating AWS_ACCESS_KEY_${ENV_UPPER}..."
                echo "$NEW_ACCESS_KEY_ID" | gh secret set "AWS_ACCESS_KEY_${ENV_UPPER}" --org "$GITHUB_ORG" 2>&1 || {
                  echo "  ⚠️  Warning: Failed to update AWS_ACCESS_KEY_${ENV_UPPER}"
                }
                
                echo "  Updating AWS_SECRET_KEY_${ENV_UPPER}..."
                echo "$NEW_SECRET_ACCESS_KEY" | gh secret set "AWS_SECRET_KEY_${ENV_UPPER}" --org "$GITHUB_ORG" 2>&1 || {
                  echo "  ⚠️  Warning: Failed to update AWS_SECRET_KEY_${ENV_UPPER}"
                }
                
                echo "  ✅ GitHub organization secrets updated successfully!"
                echo "    - AWS_ACCESS_KEY_${ENV_UPPER}: Updated"
                echo "    - AWS_SECRET_KEY_${ENV_UPPER}: Updated"
              fi
            fi
          fi
        else
          echo ""
          echo "ℹ️  Note: GitHub secrets update skipped (update-github-secrets not set to true)"
          echo "    To enable automatic updates, set update-github-secrets: true and provide github-pat"
        fi
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

